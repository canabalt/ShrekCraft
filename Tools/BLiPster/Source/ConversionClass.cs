using System;       
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Xml;
using System.IO;

namespace BLPConverterGUI
{
    public class ConversionFileInfo
    {
        public FileInfo Source { get; set; }
        public FileInfo Target { get; set; }
        public bool IsComplete { get; set; }
    }

    public class ConversionFileList : ObservableCollection<ConversionFileInfo>
    {
        private enum FileNameType { FullName, Path, Name, Extension };
        private enum ThisFile { Source, Target };

        private ObservableCollection<string> _filenames(FileNameType fType, ThisFile tf)
        {
            ObservableCollection<string> temp = new ObservableCollection<string>();
            foreach (ConversionFileInfo fi in this)
                temp.Add((fType == FileNameType.FullName ? (tf == ThisFile.Source ? fi.Source.FullName : fi.Target.FullName) :
                         (fType == FileNameType.Path ? (tf == ThisFile.Source ? fi.Source.DirectoryName : fi.Target.DirectoryName) :
                         (fType == FileNameType.Name ? (tf == ThisFile.Source ? fi.Source.Name : fi.Target.Name) :
                         (fType == FileNameType.Extension ? (tf == ThisFile.Source ? fi.Source.Extension : fi.Target.Extension) : "")))));
            return temp;
        }

        public ObservableCollection<string> SourceFilenames()
        {
            return _filenames(FileNameType.Name, ThisFile.Source);
        }

        public ConversionFileList(System.Collections.Generic.IEnumerable<FileInfo> fiColl)
        {
            Add(fiColl);
        }

        public ConversionFileList()
        {
        }

        public bool Contains(FileInfo fi)
        {
            return (_filenames(FileNameType.FullName, ThisFile.Source).IndexOf(fi.FullName) > -1);
        }

        public void Add(FileInfo fi)
        {
            if (!Contains(fi))
                base.Add(new ConversionFileInfo() { Source = fi, Target = null, IsComplete = false });
        }

        public void Add(System.Collections.Generic.IEnumerable<FileInfo> fiColl)
        {
            foreach (FileInfo fi in fiColl)
                if (!Contains(fi))
                    base.Add(new ConversionFileInfo() { Source = fi, Target = null, IsComplete = false });
        }
    }

    public class FileList : ObservableCollection<FileInfo>
    {
        private enum FileNameType { FullName, Path, Name, Extension };

        private ObservableCollection<string> _filenames(FileNameType fType)
        {
            ObservableCollection<string> temp = new ObservableCollection<string>();
            foreach (FileInfo fi in this)
                temp.Add((fType == FileNameType.FullName ? fi.FullName :
                         (fType == FileNameType.Path ? fi.DirectoryName :
                         (fType == FileNameType.Name ? fi.Name : 
                         (fType == FileNameType.Extension ? fi.Extension : "")))));
            return temp;
        }

        public ObservableCollection<string> Filenames()
        {
            return _filenames(FileNameType.Name);
        }

        public FileList(System.Collections.Generic.IEnumerable<FileInfo> fiColl)
        {
            Add(fiColl);
        }

        public FileList()
        {
        }

        public new bool Contains(FileInfo fi)
        {
            return (_filenames(FileNameType.FullName).IndexOf(fi.FullName) > -1);
        }

        public new void Add(FileInfo fi)
        {
            if (!Contains(fi))
                base.Add(fi);
        }

        public void Add(System.Collections.Generic.IEnumerable<FileInfo> fiColl)
        {
            foreach (FileInfo fi in fiColl)
                if (!Contains(fi))
                    base.Add(fi);
        }
    }
    
    public class FileFormatClass
    {
        public string Format { get; set; }
        public string Description { get; set; }
    }

    public class ConversionClass
    {
        public string SourceFormat { get; set; }
        public string TargetFormat { get; set; }

        // These are used for combining the default conversion list with a custom conversion list
        //    generated by the user.  The set is initialized with the default conversions, setting
        //    IsDefault to true and IsOverridden to false.  As the user adds/removes custom
        //    conversions, the IsOverridden value will change, but all new values will have
        //    IsDefault set to false.
        public bool IsDefault {get; set; }
        public bool IsOverridden { get; set; }

        // What's going on here?
        //
        // These values return either 1 or 0, which can be used in DataTemplate databinding to 
        //    alter the appearance of the item, based on the value.
        //    
        //    DefaultValue = the item is part of the default set of conversions
        //    OverrideValue = the item is a default but was overridden by the user
        //    NotDefaultValue = the item is not part of the default conversion set
        public int OverrideValue { get { return (IsOverridden ? 1 : 0); } }
        public int NotDefaultValue { get { return (!IsDefault ? 1 : 0); } }
        public int DefaultValue { get { return (IsDefault && !IsOverridden ? 1 : 0); } }
    }

    public class RuleReader
    {
        public static BindingList<ConversionClass> ConversionRules()
        {
            BindingList<ConversionClass> ocConversionRules = new BindingList<ConversionClass>();
            // Execute the query using the LINQ to XML
            var rules = from c in XElement.Load(XMLBuilder.ConversionRuleXml()).Elements("Conversion") select c;
            foreach (var rule in rules)
            {
                ConversionClass cRule = new ConversionClass()
                {
                    SourceFormat = rule.Element("Source").Value,
                    TargetFormat = rule.Element("Target").Value,
                    IsDefault = true,
                    IsOverridden = false
                };
                ocConversionRules.Add(cRule);
            }
            return ocConversionRules;
        }

        public static BindingList<FileFormatClass> FileFormats()
        {
            BindingList<FileFormatClass> ocConversionRules = new BindingList<FileFormatClass>();
            // Execute the query using the LINQ to XML
            var rules = from c in XElement.Load(XMLBuilder.FileFormatXml()).Elements("Format") select c;
            foreach (var rule in rules)
            {
                FileFormatClass cRule = new FileFormatClass()
                {
                    Format = rule.Element("Name").Value,
                    Description = rule.Element("Description").Value
                };
                ocConversionRules.Add(cRule);
            }
            return ocConversionRules;
        }

    }

}
